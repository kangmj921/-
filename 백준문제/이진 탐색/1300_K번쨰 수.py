# N * N인 배열을 만들때, 배열에 각 수는 [1, 2, .......N], [2, 2 * 2,..., 2 * N]....[N, N * 2, ..., N * N]
# 이 배열을 일차원 배열 B에 넣고 B를 오름차순 정렬했을 때, B[K]를 구한다.

# N = 3일때, 배열 A = [[1, 2, 3], [2, 4, 6], [3, 6, 9]] => B에 넣을때, [1, 2, 3, 2, 4, 6, 3, 6, 9]
# 오름차순 정렬 ==> [1, 2, 2, 3, 3, 4, 6, 6, 9]
# B[7] = 6

# N이 최대 10 ^ 5 이므로, 배열 A를 일일히 구현하게 되면, 시간초과에 걸린다.
# 그리고 B를 오름차순 정렬하는 과정도, B의 크기가 N * N 이므로, O(N * N)이 걸리므로
# 시간초과에 걸릴 것이다.
# A의 i행 j열의 수와 j행 i열의 수는 같다. 따라서, i == j 일때의 수(제곱수)가 아닌
# 다른 모든 수는 2번씩 나온다.
# K가 주어졌을때, i * j가 K보다 작은 수가 몇 개 인지 찾고, i와 j가 다를땐 i * j 는 2번씩
# 나오고 같을땐 1번 나오므로 그걸 더해가며 K번째 까지 왔을때의 값을 구하면 될까?
#
# K = 7이면, K = 1 ~ 7 의 범위에서, K에 대한 이분탐색을 진행하는데, K보다 작은 숫자가
# 몇개인지 찾아내면 K를 구할 수 있는데, i 가 1 부터, N까지 일때, i의 배수에 대해 k 보다 작은
# 수의 개수를 찾는다.

# 작은 수의 개수가 K 보다 크면 더 작은 범위에서 찾고 작으면 더 큰 범위에서 찾는다.

N = int(input())    # 1 <= N <= 100000
k = int(input())    # 1 <= k <= 1000000000
sqrt_list = [i * i for i in range(1, N + 1)]
start, end = 1, k

while start <= end:
    mid = (start + end) // 2
    count = 0
    for i in range(1, N + 1):
        count += min(mid // i, N)
    if count >= k:
        answer = mid
        end = mid - 1
    else:
        start = mid + 1
print(answer)
